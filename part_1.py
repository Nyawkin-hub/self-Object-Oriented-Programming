### мне лень использовать библиотеку ic, может потом переделаю

"#--------------------------------------------------------------#"
"########################### ООП ###########################"
"#______________________________________________________________#"

# ООП это
# парадигма
# программа строится вокруг объектов
# объекты сочетают в себе данные (свойства) и методы (действия)
# ООП использует ключевые принципы - инкапсуляция, наследование и полиморфизм 
# объект - сущность (экземпляр), имеющая свои свойства (данные) и методы (действия)
# класс - шаблон, по которому создаются объекты - определяет структуру и поведение объектов. 
# инкапсуляция - скрытие внутренних деталей объектов и 
# предоставление доступа к ним через определенные методы
# public private protect
# наследование - возможность создания новых классов (дочерних) на основе существующих (родительских) классов
# наследуя их свойства и методы. 
# полиморфизм  - способность объектов одного класса принимать разные формы 
# или поведение в зависимости от контекста. 

# зачем?:
# парадигма помогает создавать организованные, гибкие и масштабируемые программы 
# особенно при работе над сложными проектами

# реализация класса
class MyClass:
    pass

# реализация объекта
obj = MyClass()

"#--------------------------------------------------------------#"
"########################### Атрибуты ###########################"
"#______________________________________________________________#"


# setattr(object, name, value)
setattr(obj, 'new_attr', 10)    # Создает атрибут new_attr и присваивает ему значение 10
print(obj.new_attr)             # Вывод: 10

# getattr(object, name, default)
value = getattr(obj, 'my_attr', 'default_value')  # Возвращает 'default_value', т.к. атрибута my_attr не существует
print(value) # Вывод: default_value
value = getattr(obj, 'new_attr', obj.new_attr) # new_attr
print(value) # Вывод: 10

# delattr(object, name)
print(obj.new_attr) # Вывод: 10
delattr(obj, 'new_attr') # Удаляет атрибут attr
# print(obj.attr) # при повторном вызове после удаления будет ошибка:
# AttributeError: 'MyClass' object has no attribute 'attr'

# __dict__
class MyClass:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def nums(self):
        print(f"{self.a} is 1, {self.b} is 2")

obj = MyClass(1, 2)
print(obj.__dict__) # Вывод: {'a': 1, 'b': 2}

################### self ###################

# self — это первый параметр, который передается в методы класса
# он относится к конкретному экземпляру класса
# он используется для доступа к атрибутам и методам этого экземпляра 
# когда метод класса взаимодействует с ним. 
# когда вызывается метод класса, self автоматически ссылается на 
# объект класса, для которого вызывается этот метод.

# по примеру выше в init будут инициализированы a и b:
# передается 1 -> a
# передается 2 -> b

obj.nums() # 1 is 1, 2 is 2


"#--------------------------------------------------------------#"
"################### getter, setter, deleter ####################"
"#______________________________________________________________#"



# есть три основных свойства - getter, setter, deleter

# getter (геттер):
# метод который возвращает значение атрибута класса
# при использовании геттера, можно получить доступ к значению атрибута
# не имея возможности изменять его напрямую
# что помогает контролировать доступ к данным


# setter (сеттер):
# метод который позволяет установить новое значение атрибута
# сеттер обычно содержит логику валидации перед изменением значения
# чтобы гарантировать что данные соответствуют определенным правилам


# deleter (делетер):
# метод который позволяет удалять атрибут
# он полезен когда нужно удалить значение атрибута
# чтобы освободить память или изменить состояние объекта. 


#реализуем быстро новый класс Person с геттером и сеттером и делитером
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    @property                                       # @ - это декоратор - будет потом - 
                                                    # мега важная штука, которая ценится но не часто используется
                                                    # p.s. property важный класс советую почитать
    def full_name(self):                            # - наш геттер который возвращает значение name и/или surname
        print(self.name + " " + self.surname)
        return self.name + " " + self.surname
    
    @full_name.setter                               # декорация будет потом, сейчас просто так надо
    def full_name(self, new):                       # сеттер для свойства full_name
        self.name, self.surname = new.split(" ")
        
    @full_name.deleter                              # декорация будет потом, сейчас просто так надо
    def full_name(self):                            # делитер для свойства full_name
        del self.name
        del self.surname
        
        
        
person = Person("Имя", "Фамилия")
setattr(person, 'new_attr', 10)       
person.full_name                                # выведет Имя Фамилия
person.full_name = "НовоеИмя НоваяФамилия"
person.full_name                                # выведет НовоеИмя НоваяФамилия
# то есть мы можем присвоить СВОЙСТВУ full_name новые Имя Фамилия благодаря создани геттера

person.name                                     # ничего не выведет если че но вернется name
print(person.surname)                           
# типа работает так:
# обращение к объкту персон -> находит метод surname (есть благодаря геттеру)
# далее вернется НоваяФамилия и дальше вывод по принту

# ну и в конце концов мы по факту удаляем атрибут full_name:
del person.full_name
# print(person.full_name) # тут будет ошибка 
# AttributeError: 'Person' object has no attribute 'name' 
# потому что мы удалили и name и surname 
#


"#-----------------------------------------------------------------------#"
"########################### магические методы ###########################"
"#_______________________________________________________________________#"


#
# крч магические методы (dunder) это типа __имяметода__
# например __new__ ; __init__ ; __del__ ; или тому подобные 
# не знаю почему назвали магическими но они просто классные и их знание дает +1000 к ауре
# иногда они вызываются сами например __new__ при создании типа класса
# их много читаются в интернетики 
# основные для ооп знать обязательно 
#



"#------------------------------------------------------------------------#"
"########################### Статические методы ###########################"
"#________________________________________________________________________#"


# это методы класса
# они не привязаны к конкретному экземпляру класса, а работают с самим классом
# объявляются с помощью декоратора @staticmethod и не принимают параметр self или cls
# как это делают методы экземпляра и методы класса.
# у них нет доступа к состояние объекта (не изменяют состояние)
# по факту нужны для создания логики которая не требует данных
# самое простое это просто вернуть сумму

class MyClass:
    @staticmethod 
    def static_method(argument1, argument2):
        return argument1 + argument2

# вызов статического метода через имя класса
result = MyClass.static_method(1, 2)
print(result)  # Output: 3

# вызывать через экземпляр не рекомендуется тк они принадлежат нашему классу, а не экземпляру


"____________________________расписывать не буду но slots важная штука_____________________________"


# есть такая вещь слоты: __slots__ = ()
# оно просто быстрее на операциях доступа к атрибутам
# прочитать можно везде на хабре или еще где нибудь
# помогает оптимизировать всякие штуки главное использовать правильно

