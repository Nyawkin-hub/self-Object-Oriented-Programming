"#-----------------------------------------------------------------------#"
"############################# Borg-паттерн ##############################"
"#_______________________________________________________________________#"

# шаблон проектирования, при котором все экземпляры класса разделяют одно и то же состояние 
# (один словарь __dict__) но остаются разными объектами
# Это альтернатива синглтону
# вместо ограничения количества экземпляров (один объект), 
# здесь допускается множество объектов, но с общим состоянием

class Borg:
    _shared_state = {}  # общее состояние для всех экземпляров

    def __init__(self):
        self.__dict__ = self._shared_state  # перенаправляем __dict__ на общее хранилище

a = Borg()
b = Borg()

a.x = 42    # тут мы делаем значение х в экземпляре а
print(b.x)  # а тут будет 42 потому что а и б это одно и то состояние
# то есть если мы изменим х в экземпляре б, то и в а он поменяется
# но при этом а и б это разные объекты
# эта штука нужна когда нужно скоординировать состояние между объектами
# но при этом не нужно ограничивать количество экземпляров класса

"#-----------------------------------------------------------------------#"
"########################### Singleton-паттерн ###########################"
"#_______________________________________________________________________#"

# паттерн проектирования
# который гарантирует, что в приложении существует только один экземпляр определённого класса
# и предоставляет глобальную точку доступа к этому экземпляру

class Singleton:
    _instance = None  # тут хранится единственный экземпляр класса

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

a = Singleton()
b = Singleton()

print(a is b)  # тут будет тру ну потому что а и б это один и тот же экземпляр класса
# то есть если мы изменим атрибут в а, то он изменится и в б
# и наоборот

a.x = 42
print(b.x)  # тут будет 42 потому что а и б это один и тот же экземпляр класса

# применять можно в пуле подключений к бд или сессия в редисе, но это уже другая история

"#-----------------------------------------------------------------------#"
"############################# enter - exit ##############################"
"#_______________________________________________________________________#"

# мы ща только что написали декоратор с параметром и для логирования легкой функции
# тогда и сделаем класс логгер

# это короче контекстный менеджер 
# объект, который реализует протокол контекста: 
# методы __enter__() и __exit__(). 
# Такой класс можно использовать в конструкции with ... as ...
# и он обеспечивает управление ресурсами: открытие, инициализацию
# а затем гарантированное освобождение, даже при ошибках.
# 
# вот его общая реализация
class MyContext:
    def __enter__(self):
        print("двери открываются")
        return self  # тут чето происходит с ресурсами на складе

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("двери закрываются")
        if exc_type:
            print(f"Произошло исключение: {exc_val}")

with MyContext() as ctx:
    print("носим ящики")
    # raise ValueError("типа ошибка вкинулась") это надо раскомменитить чтобы сработало

# короче как это работает 
# блок with - мы в него входим
# при входе вызывается собственно __enter__ как и переводится - вход
# далее какое значение (в нашем случае self) передается в as
# мы чето поделали и все, двери надо закрыть
# далее срабатывает __exit__ когда мы выходим из блока
#
# ну и далее логер класса небольшой

class Logger:
    def __init__(self, tag):
        self.tag = tag

    def __enter__(self):
        print(f"[{self.tag}] открыли складик")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"[{self.tag}] закрыли складик")
        if exc_type:
            print(f"[{self.tag}] ошибка: {exc_val}")
            
with Logger("enter и exit"):
    print("какие то штуки делаем")

# согласен оченб классная штука
# нужна чтбы управлять сессия в какой нибудь sqlalchemy 
# или для работы с файликами, то есть там достали цифру из ексель и что то с ней сделали
# и ваще много че можно придумать, по сути обработка какой то информации в блоке with 


"#---------------------------------------------------------------------------------------#"
"############################# hasattr ; getattr ; delattr  ##############################"
"#_______________________________________________________________________________________#"


# тут "attr" это название аттрибута объекта в классе 
# hasattr(obj, "attr")	        проверка на наличие у объекта атрибута "attr" (возвращает True/False)
# getattr(obj, "attr", default)	получение значения "attr" (или default, если нет)
# setattr(obj, "attr", value)	поставить значение атрибута "attr"
# delattr(obj, "attr")	        удалить атрибут "attr" у объекта

# вот примерчик
class Person:
    def __init__(self, name):
        self.name = name
        self.role = "guest"

u = Person("Аврелий")

print(hasattr(u, "name"))           # True тк есть аттрибут name
print(getattr(u, "name"))           # вывод "Аврелий" тк сработал геттер
print(getattr(u, "age", 30))        # 30 (дефолт, если атрибута нет)

setattr(u, "age", 25)               # тут поставили новый аттрибут "age", хоть в классе его и не было
print(u.age)                        # 25

delattr(u, "role")                  # удалили аттрибут "role"
print(hasattr(u, "role"))           # False

# тут name age role это если че не просто прикол какой то, это атрибут

"############################# честно говоря хз че писать еще в этой части, в целом все ##############################"
# единственное можно просто смотреть читать магические (dunder) методы классов в питоне 
