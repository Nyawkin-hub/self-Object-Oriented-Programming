# вспомнил что надо было написать декоратор
# я напишу крч сразу с параметром - это типа трехуровневая система
# как говорится умеешь посложнее, разберешься с полегче

import functools
# эта библиотека всегда нужна потому что там декоратор сидит 
# то есть по сути мы обернем обертку в обертку

# обычный декоратор для логирования с разными уровнями
def log(level="Если мы не передали параметр"):  
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"[{level}] Вызов: {func.__name__} с args={args}, kwargs={kwargs}")
            result = func(*args, **kwargs)
            print(f"[{level}] Результат: {result}")
            return result
        return wrapper
    return decorator

# первый уровень функция log с одним параметром
# если че он равен инфо это если мы ниче не передали в него
# 
# второй уровень тут мы передаем функцию
# 
# далее третий уровень - рапер - это и есть главная штука
# тут по сути три действия 
# первый принт как видно он делается то основной программы
# далее в резалтик записывать результат функции, которую мы обернем декоратором
# и дальше принт - то что будет после
# и соответственно возвращаем резалтик рапер и декоратор по уровням тк это функции и они всегда должна что то вернуть
#
# собственно говоря прикол в действия до и после 
# то есть вместо принта могут быть какие то вычисления или логирование как в этом случае
# вот примерчик ща сделаю


@log(level="Тут мы передали параметр") # обернули в декоратор
def add(a, b): 
    return a + b

add(2, 3)



# получается что мы сделали
# выходит первый принт "Вызов" - то есть то что случилось до вызова функции
# далее функция посчиталась и ответ записался в резалт, в резалте чисто а + б ща сидит
# далее принтит после просчетов функции - даже пометка Результат и число посчитанное от а + б
# можно еще для прикола добавить принт в функцию add где считается и он выведет между первым и вторым принтом
#


@log()                  # обернули в декоратор
def divide(a, b):
    return a / b

divide(10, 2)

# ну а тут будет то же самое только деление и вместо передачи аргумента мы его не передавали
# поэтому используется дефолтное значение переменной
# лучше его всегда указывать
#
# этот декоратор не очень часто видно или типа того потому что он нужен 
# на моем опыте
# для мониторинка или логирования 
# 
# еще вроде можно для авторизации использовать, для валидности, но я не пробовал пока что
#
# вообще можно выучить просто как выглядит декоратор и все
# функция с параметром с дефолтным значением
# функция с аргументом функции
# декоратор рапс с аргументом функции из библиотеки
# функция рапер с *арг и **кваргс - сами читайте че такое арги кварги - это легко
# до результат после
# три return на три функции